
// 해체 할당

// ES6에서 새로 도입한 해체 할당(destructuring assignment)는
// 매우 환영 받는 기능이다.
// 이 기능은 객체나 배열을
// 변수로 '해체'할 수 있다.

// 객체 선언
const obj = {b: 2, c: 3, d: 4};

// 해체 할당
const {a, b, c} = obj;
a;      // undefined: obj에는 "a" 프로퍼티가 없다.
b;      // 2
c;      // 3
d;      // ReferenceError: "d"는 정의되지 않았다.

// 객체를 해체할 때는 반드시 변수의 이름과 객체의 프로퍼티 이름이 일치해야 한다.
// 프로퍼티 이름이 유효한 식별자인 프로퍼티만 해체 후 할당된다.
// 위 예제에서는 obj에 a 프로퍼티가 없으므로 a는 undefined를 할당 받는다.
// 그리고, 해체 할당에 d라는 프로퍼티가 없으므로 d는 선언조차 되지 않는다.

// 위 예제에서는 선언과 할당을 같은 문에서 실행했다.
// 객체 해체는 할당만으로 이뤄딜 수도 있지만, 그렇게 하려면 반드시 괄호를 써야 한다.
// 괄호를 쓰지 않으면 js는 표현식 좌변을 블록으로 해석한다.

const obj = {b: 2, c: 3, d: 4};
let a, b, c;        // 먼저 변수를 선언했다.

{a, b, c} = obj;    // 에러가 일어난다.(좌변을 블록으로 인식하기 때문에.)
({a, b, c} = obj);  // 동작한다.

// 배열을 해체할 때는 
// 배열 요소에 대응할 변수 이름을 마음대로 쓸 수 있으며 
// 이들은 배열 순서대로 대응한다.

const arr = [1, 2, 3];      // 배열 선언

let [x, y] = arr;           // 배열 해체 할당
x;                          // 1    배열 순서대로 값을 할당
y;                          // 2
z;                          // ReferenceError "z"는 정의되지 않았다.
// 위 예제에서는 x는 배열의 첫 번째 요소 값을, y는 두 번째 요소 값을 할당받는다.
// 그 뒤에 배열 요소는 모두 버려진다.
// 확산 연산자spread operator(...)를 사용하면 남은 요소를 새 배열에 할당할 수 있다.

const arr = [1, 2, 3, 4, 5];

let [x, y, ...rest] = arr;
x;                          // 1
y;                          // 2
rest;                       // [3, 4, 5]
// 이 예제에서 x와 y는 배열의 처음 두 요소를 받고,
// 변수 rest에는 나머지가 저장된다.
// 배열 해체를 활용하면 변수의 값을 서로 바꿀수 있다.
// 해체를 사용하지 않으면 임시 변수가 필수적인 작업이다.

let a = 5, b = 10;
[a, b] = [b, a];
a;                          // 10
b;                          // 5

// 배열 해체는 꼭 배열에만 사용할 수 있는 것은 아니다.
// 이터러블 객체레는 모두 사용할 수 있다.(9장)

// 여기서 살펴본 간단한 예제 정도라면 굳이 해체를 사용하지 않고
// 그냥 변수에 값을 할당하는 게 더 편했을 것이다.
// 해체의 진가는 다른 곳에서 가져온 객체나 배열에서 원하는 요소를 뽑아내야 할 때 드러난다.(6장)



